<!DOCTYPE html>
<html lang="bn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bangla TTS Recording App</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            color: #4ecca3;
        }
        
        .status-bar {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .progress-info {
            font-size: 0.9rem;
        }
        
        .progress-bar {
            width: 200px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: #4ecca3;
            transition: width 0.3s ease;
        }
        
        .sentence-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .sentence-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .sentence-number {
            background: #4ecca3;
            color: #1a1a2e;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
        }
        
        .recording-status {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
        }
        
        .status-recorded {
            background: #4ecca3;
            color: #1a1a2e;
        }
        
        .status-pending {
            background: #f39c12;
            color: #1a1a2e;
        }
        
        .sentence-text {
            font-size: 1.8rem;
            line-height: 1.6;
            text-align: center;
            padding: 30px 0;
            color: #fff;
            font-family: 'Noto Sans Bengali', 'Kalpurush', 'SolaimanLipi', 'Vrinda', 'Lohit Bengali', 'FreeSans', sans-serif;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-record {
            background: #e74c3c;
            color: #fff;
        }
        
        .btn-record:hover:not(:disabled) {
            background: #c0392b;
            transform: scale(1.05);
        }
        
        .btn-record.recording {
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .btn-stop {
            background: #95a5a6;
            color: #fff;
        }
        
        .btn-stop:hover:not(:disabled) {
            background: #7f8c8d;
        }
        
        .btn-play {
            background: #3498db;
            color: #fff;
        }
        
        .btn-play:hover:not(:disabled) {
            background: #2980b9;
        }
        
        .btn-delete {
            background: #e74c3c;
            color: #fff;
        }
        
        .btn-delete:hover:not(:disabled) {
            background: #c0392b;
        }
        
        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .btn-nav {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 12px 25px;
        }
        
        .btn-nav:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .sentence-jump {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .sentence-jump input {
            width: 80px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            text-align: center;
        }
        
        .sentence-jump button {
            background: #4ecca3;
            color: #1a1a2e;
        }
        
        .visualizer {
            margin: 20px 0;
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .visualizer canvas {
            width: 100%;
            height: 100%;
        }
        
        .message {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 10px;
            animation: slideIn 0.3s ease;
            z-index: 1000;
        }
        
        .message-success {
            background: #4ecca3;
            color: #1a1a2e;
        }
        
        .message-error {
            background: #e74c3c;
            color: #fff;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .keyboard-shortcuts {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            font-size: 0.85rem;
        }
        
        .keyboard-shortcuts h3 {
            margin-bottom: 10px;
            color: #4ecca3;
        }
        
        .shortcuts-list {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .shortcut {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .key {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 10px;
            border-radius: 4px;
            font-family: monospace;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Bengali:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <header>
            <h1>üéôÔ∏è Bangla TTS Recording App</h1>
            <p>Record audio samples for custom voice training</p>
        </header>
        
        <div class="status-bar">
            <div class="progress-info">
                <span id="recorded-count">0</span> / <span id="total-count">{{ total }}</span> sentences recorded
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
            </div>
        </div>
        
        <div class="sentence-card">
            <div class="sentence-header">
                <span class="sentence-number" id="sentence-number">Sentence #1</span>
                <span class="recording-status status-pending" id="recording-status">Not Recorded</span>
            </div>
            
            <div class="sentence-text" id="sentence-text">Loading...</div>
            
            <div class="visualizer">
                <canvas id="visualizer"></canvas>
            </div>
            
            <div class="controls">
                <button class="btn btn-record" id="btn-record" onclick="toggleRecording()">
                    <span>üî¥</span> <span id="record-text">Record</span>
                </button>
                <button class="btn btn-stop" id="btn-stop" onclick="stopRecording()" disabled>
                    <span>‚¨õ</span> Stop
                </button>
                <button class="btn btn-play" id="btn-play" onclick="playAudio()" disabled>
                    <span>‚ñ∂Ô∏è</span> Play
                </button>
                <button class="btn btn-delete" id="btn-delete" onclick="deleteAudio()" disabled>
                    <span>üóëÔ∏è</span> Delete
                </button>
            </div>
            
            <div class="navigation">
                <button class="btn btn-nav" id="btn-prev" onclick="goToPrevious()">
                    ‚Üê Previous
                </button>
                <div class="sentence-jump">
                    <input type="number" id="jump-input" min="1" max="{{ total }}" placeholder="#">
                    <button class="btn" onclick="jumpToSentence()">Go</button>
                </div>
                <button class="btn btn-nav" id="btn-next" onclick="goToNext()">
                    Next ‚Üí
                </button>
            </div>
        </div>
        
        <div class="keyboard-shortcuts">
            <h3>‚å®Ô∏è Keyboard Shortcuts</h3>
            <div class="shortcuts-list">
                <div class="shortcut"><span class="key">Space</span> Record/Stop</div>
                <div class="shortcut"><span class="key">P</span> Play</div>
                <div class="shortcut"><span class="key">‚Üê</span> Previous</div>
                <div class="shortcut"><span class="key">‚Üí</span> Next</div>
                <div class="shortcut"><span class="key">Del</span> Delete</div>
            </div>
        </div>
    </div>
    
    <script>
        // Configuration
        const SAMPLE_RATE = {{ sample_rate }};
        const sentences = {{ sentences | tojson }};
        let currentIndex = 0;
        
        // Audio recording state
        let mediaRecorder = null;
        let audioContext = null;
        let analyser = null;
        let audioStream = null;
        let recordedChunks = [];
        let isRecording = false;
        let currentAudioBuffer = null;
        
        // DOM Elements
        const sentenceText = document.getElementById('sentence-text');
        const sentenceNumber = document.getElementById('sentence-number');
        const recordingStatus = document.getElementById('recording-status');
        const btnRecord = document.getElementById('btn-record');
        const btnStop = document.getElementById('btn-stop');
        const btnPlay = document.getElementById('btn-play');
        const btnDelete = document.getElementById('btn-delete');
        const btnPrev = document.getElementById('btn-prev');
        const btnNext = document.getElementById('btn-next');
        const recordText = document.getElementById('record-text');
        const canvas = document.getElementById('visualizer');
        const canvasCtx = canvas.getContext('2d');
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            await loadStatus();
            displaySentence(currentIndex);
            setupKeyboardShortcuts();
            setupCanvas();
        });
        
        function setupCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        
        async function loadStatus() {
            try {
                const response = await fetch('/api/status');
                const status = await response.json();
                document.getElementById('recorded-count').textContent = status.recorded;
                document.getElementById('total-count').textContent = status.total;
                const progress = (status.recorded / status.total) * 100;
                document.getElementById('progress-fill').style.width = progress + '%';
            } catch (error) {
                console.error('Error loading status:', error);
            }
        }
        
        async function displaySentence(index) {
            if (index < 0 || index >= sentences.length) return;
            
            currentIndex = index;
            const sentence = sentences[index];
            
            sentenceText.textContent = sentence.text;
            sentenceNumber.textContent = `Sentence #${sentence.id}`;
            
            // Check if recorded
            try {
                const response = await fetch(`/api/sentence/${sentence.id}`);
                const data = await response.json();
                
                if (data.recorded) {
                    recordingStatus.textContent = 'Recorded ‚úì';
                    recordingStatus.className = 'recording-status status-recorded';
                    btnPlay.disabled = false;
                    btnDelete.disabled = false;
                } else {
                    recordingStatus.textContent = 'Not Recorded';
                    recordingStatus.className = 'recording-status status-pending';
                    btnPlay.disabled = true;
                    btnDelete.disabled = true;
                }
            } catch (error) {
                console.error('Error checking recording status:', error);
            }
            
            // Update navigation buttons
            btnPrev.disabled = index === 0;
            btnNext.disabled = index === sentences.length - 1;
            
            // Update jump input
            document.getElementById('jump-input').value = sentence.id;
        }
        
        async function toggleRecording() {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }
        
        async function startRecording() {
            try {
                audioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: SAMPLE_RATE,
                        channelCount: 1,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    } 
                });
                
                // Setup audio context for visualization
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: SAMPLE_RATE
                });
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(audioStream);
                source.connect(analyser);
                analyser.fftSize = 256;
                
                // Setup MediaRecorder
                mediaRecorder = new MediaRecorder(audioStream, {
                    mimeType: 'audio/webm'
                });
                
                recordedChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(recordedChunks, { type: 'audio/webm' });
                    await processAndSaveAudio(audioBlob);
                };
                
                mediaRecorder.start();
                isRecording = true;
                
                btnRecord.classList.add('recording');
                recordText.textContent = 'Recording...';
                btnStop.disabled = false;
                btnPlay.disabled = true;
                btnDelete.disabled = true;
                
                // Start visualization
                visualize();
                
            } catch (error) {
                console.error('Error starting recording:', error);
                showMessage('Error accessing microphone. Please allow microphone access.', 'error');
            }
        }
        
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                
                btnRecord.classList.remove('recording');
                recordText.textContent = 'Record';
                btnStop.disabled = true;
                
                if (audioStream) {
                    audioStream.getTracks().forEach(track => track.stop());
                }
                
                // Clear visualization
                canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }
        
        async function processAndSaveAudio(audioBlob) {
            try {
                // Decode audio blob to get samples
                const arrayBuffer = await audioBlob.arrayBuffer();
                const tempContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioBuffer = await tempContext.decodeAudioData(arrayBuffer);
                
                // Resample to target sample rate if needed
                let samples;
                if (audioBuffer.sampleRate !== SAMPLE_RATE) {
                    const offlineContext = new OfflineAudioContext(
                        1,
                        audioBuffer.duration * SAMPLE_RATE,
                        SAMPLE_RATE
                    );
                    const source = offlineContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(offlineContext.destination);
                    source.start();
                    const resampledBuffer = await offlineContext.startRendering();
                    samples = Array.from(resampledBuffer.getChannelData(0));
                } else {
                    samples = Array.from(audioBuffer.getChannelData(0));
                }
                
                // Save to server
                const sentence = sentences[currentIndex];
                const response = await fetch('/api/save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        sentence_id: sentence.id,
                        audio_data: samples
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showMessage('Audio saved successfully!', 'success');
                    await loadStatus();
                    
                    // Update current sentence status
                    recordingStatus.textContent = 'Recorded ‚úì';
                    recordingStatus.className = 'recording-status status-recorded';
                    btnPlay.disabled = false;
                    btnDelete.disabled = false;
                    
                    // Auto-advance to next sentence
                    if (currentIndex < sentences.length - 1) {
                        setTimeout(() => {
                            goToNext();
                        }, 500);
                    }
                } else {
                    showMessage('Error saving audio: ' + result.error, 'error');
                }
                
                tempContext.close();
                
            } catch (error) {
                console.error('Error processing audio:', error);
                showMessage('Error processing audio: ' + error.message, 'error');
            }
        }
        
        async function playAudio() {
            const sentence = sentences[currentIndex];
            try {
                const response = await fetch(`/api/audio/${sentence.id}`);
                if (response.ok) {
                    const audioBlob = await response.blob();
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);
                    audio.play();
                } else {
                    showMessage('Audio file not found', 'error');
                }
            } catch (error) {
                console.error('Error playing audio:', error);
                showMessage('Error playing audio', 'error');
            }
        }
        
        async function deleteAudio() {
            const sentence = sentences[currentIndex];
            if (!confirm(`Delete recording for sentence #${sentence.id}?`)) return;
            
            try {
                const response = await fetch(`/api/delete/${sentence.id}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showMessage('Audio deleted', 'success');
                    await loadStatus();
                    
                    // Update UI
                    recordingStatus.textContent = 'Not Recorded';
                    recordingStatus.className = 'recording-status status-pending';
                    btnPlay.disabled = true;
                    btnDelete.disabled = true;
                } else {
                    showMessage('Error deleting audio', 'error');
                }
            } catch (error) {
                console.error('Error deleting audio:', error);
                showMessage('Error deleting audio', 'error');
            }
        }
        
        function goToPrevious() {
            if (currentIndex > 0) {
                displaySentence(currentIndex - 1);
            }
        }
        
        function goToNext() {
            if (currentIndex < sentences.length - 1) {
                displaySentence(currentIndex + 1);
            }
        }
        
        function jumpToSentence() {
            const input = document.getElementById('jump-input');
            const targetId = input.value;
            
            // Use loose equality to handle type differences
            const index = sentences.findIndex(s => s.id == targetId);
            if (index !== -1) {
                displaySentence(index);
            } else {
                showMessage('Sentence not found', 'error');
            }
        }
        
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Ignore if typing in input
                if (e.target.tagName === 'INPUT') return;
                
                switch (e.code) {
                    case 'Space':
                        e.preventDefault();
                        toggleRecording();
                        break;
                    case 'KeyP':
                        if (!btnPlay.disabled) playAudio();
                        break;
                    case 'ArrowLeft':
                        goToPrevious();
                        break;
                    case 'ArrowRight':
                        goToNext();
                        break;
                    case 'Delete':
                        if (!btnDelete.disabled) deleteAudio();
                        break;
                }
            });
        }
        
        function visualize() {
            if (!isRecording) return;
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            const draw = () => {
                if (!isRecording) {
                    canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
                    return;
                }
                
                requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                
                canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
                
                const barWidth = (canvas.width / bufferLength) * 2.5;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * canvas.height;
                    
                    const gradient = canvasCtx.createLinearGradient(0, canvas.height - barHeight, 0, canvas.height);
                    gradient.addColorStop(0, '#4ecca3');
                    gradient.addColorStop(1, '#2ecc71');
                    
                    canvasCtx.fillStyle = gradient;
                    canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    
                    x += barWidth + 1;
                }
            };
            
            draw();
        }
        
        function showMessage(text, type) {
            const message = document.createElement('div');
            message.className = `message message-${type}`;
            message.textContent = text;
            document.body.appendChild(message);
            
            setTimeout(() => {
                if (message.parentNode) {
                    message.remove();
                }
            }, 3000);
        }
    </script>
</body>
</html>
